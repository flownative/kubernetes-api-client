<?php

declare(strict_types=1);

/*
 * This file has been auto generated by Jane,
 *
 * Do no edit it directly.
 */

namespace Flownative\Kubernetes\Api\Model;

class IoK8sApiCoreV1Volume
{
    /**
     * @var array
     */
    protected $initialized = [];

    public function isInitialized($property): bool
    {
        return array_key_exists($property, $this->initialized);
    }
    /**
     * Represents a Persistent Disk resource in AWS.
     *
     * An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.
     *
     * @var IoK8sApiCoreV1AWSElasticBlockStoreVolumeSource|null
     */
    protected $awsElasticBlockStore;
    /**
     * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
     *
     * @var IoK8sApiCoreV1AzureDiskVolumeSource|null
     */
    protected $azureDisk;
    /**
     * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
     *
     * @var IoK8sApiCoreV1AzureFileVolumeSource|null
     */
    protected $azureFile;
    /**
     * Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.
     *
     * @var IoK8sApiCoreV1CephFSVolumeSource|null
     */
    protected $cephfs;
    /**
     * Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.
     *
     * @var IoK8sApiCoreV1CinderVolumeSource|null
     */
    protected $cinder;
    /**
     * Adapts a ConfigMap into a volume.
     *
     * The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.
     *
     * @var IoK8sApiCoreV1ConfigMapVolumeSource|null
     */
    protected $configMap;
    /**
     * Represents a source location of a volume to mount, managed by an external CSI driver.
     *
     * @var IoK8sApiCoreV1CSIVolumeSource|null
     */
    protected $csi;
    /**
     * DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
     *
     * @var IoK8sApiCoreV1DownwardAPIVolumeSource|null
     */
    protected $downwardAPI;
    /**
     * Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.
     *
     * @var IoK8sApiCoreV1EmptyDirVolumeSource|null
     */
    protected $emptyDir;
    /**
     * Represents an ephemeral volume that is handled by a normal storage driver.
     *
     * @var IoK8sApiCoreV1EphemeralVolumeSource|null
     */
    protected $ephemeral;
    /**
     * Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling.
     *
     * @var IoK8sApiCoreV1FCVolumeSource|null
     */
    protected $fc;
    /**
     * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
     *
     * @var IoK8sApiCoreV1FlexVolumeSource|null
     */
    protected $flexVolume;
    /**
     * Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling.
     *
     * @var IoK8sApiCoreV1FlockerVolumeSource|null
     */
    protected $flocker;
    /**
     * Represents a Persistent Disk resource in Google Compute Engine.
     *
     * A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling.
     *
     * @var IoK8sApiCoreV1GCEPersistentDiskVolumeSource|null
     */
    protected $gcePersistentDisk;
    /**
     * Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.
     *
     * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
     *
     * @var IoK8sApiCoreV1GitRepoVolumeSource|null
     */
    protected $gitRepo;
    /**
     * Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling.
     *
     * @var IoK8sApiCoreV1GlusterfsVolumeSource|null
     */
    protected $glusterfs;
    /**
     * Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling.
     *
     * @var IoK8sApiCoreV1HostPathVolumeSource|null
     */
    protected $hostPath;
    /**
     * ImageVolumeSource represents a image volume resource.
     *
     * @var IoK8sApiCoreV1ImageVolumeSource|null
     */
    protected $image;
    /**
     * Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.
     *
     * @var IoK8sApiCoreV1ISCSIVolumeSource|null
     */
    protected $iscsi;
    /**
     * name of the volume. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names.
     *
     * @var string|null
     */
    protected $name;
    /**
     * Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support ownership management or SELinux relabeling.
     *
     * @var IoK8sApiCoreV1NFSVolumeSource|null
     */
    protected $nfs;
    /**
     * PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).
     *
     * @var IoK8sApiCoreV1PersistentVolumeClaimVolumeSource|null
     */
    protected $persistentVolumeClaim;
    /**
     * Represents a Photon Controller persistent disk resource.
     *
     * @var IoK8sApiCoreV1PhotonPersistentDiskVolumeSource|null
     */
    protected $photonPersistentDisk;
    /**
     * PortworxVolumeSource represents a Portworx volume resource.
     *
     * @var IoK8sApiCoreV1PortworxVolumeSource|null
     */
    protected $portworxVolume;
    /**
     * Represents a projected volume source.
     *
     * @var IoK8sApiCoreV1ProjectedVolumeSource|null
     */
    protected $projected;
    /**
     * Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support ownership management or SELinux relabeling.
     *
     * @var IoK8sApiCoreV1QuobyteVolumeSource|null
     */
    protected $quobyte;
    /**
     * Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling.
     *
     * @var IoK8sApiCoreV1RBDVolumeSource|null
     */
    protected $rbd;
    /**
     * ScaleIOVolumeSource represents a persistent ScaleIO volume.
     *
     * @var IoK8sApiCoreV1ScaleIOVolumeSource|null
     */
    protected $scaleIO;
    /**
     * Adapts a Secret into a volume.
     *
     * The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.
     *
     * @var IoK8sApiCoreV1SecretVolumeSource|null
     */
    protected $secret;
    /**
     * Represents a StorageOS persistent volume resource.
     *
     * @var IoK8sApiCoreV1StorageOSVolumeSource|null
     */
    protected $storageos;
    /**
     * Represents a vSphere volume resource.
     *
     * @var IoK8sApiCoreV1VsphereVirtualDiskVolumeSource|null
     */
    protected $vsphereVolume;

    /**
     * Represents a Persistent Disk resource in AWS.
     *
     * An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.
     */
    public function getAwsElasticBlockStore(): ?IoK8sApiCoreV1AWSElasticBlockStoreVolumeSource
    {
        return $this->awsElasticBlockStore;
    }

    /**
     * Represents a Persistent Disk resource in AWS.
     *
     * An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.
     */
    public function setAwsElasticBlockStore(?IoK8sApiCoreV1AWSElasticBlockStoreVolumeSource $awsElasticBlockStore): self
    {
        $this->initialized['awsElasticBlockStore'] = true;
        $this->awsElasticBlockStore = $awsElasticBlockStore;

        return $this;
    }

    /**
     * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
     */
    public function getAzureDisk(): ?IoK8sApiCoreV1AzureDiskVolumeSource
    {
        return $this->azureDisk;
    }

    /**
     * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
     */
    public function setAzureDisk(?IoK8sApiCoreV1AzureDiskVolumeSource $azureDisk): self
    {
        $this->initialized['azureDisk'] = true;
        $this->azureDisk = $azureDisk;

        return $this;
    }

    /**
     * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
     */
    public function getAzureFile(): ?IoK8sApiCoreV1AzureFileVolumeSource
    {
        return $this->azureFile;
    }

    /**
     * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
     */
    public function setAzureFile(?IoK8sApiCoreV1AzureFileVolumeSource $azureFile): self
    {
        $this->initialized['azureFile'] = true;
        $this->azureFile = $azureFile;

        return $this;
    }

    /**
     * Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.
     */
    public function getCephfs(): ?IoK8sApiCoreV1CephFSVolumeSource
    {
        return $this->cephfs;
    }

    /**
     * Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.
     */
    public function setCephfs(?IoK8sApiCoreV1CephFSVolumeSource $cephfs): self
    {
        $this->initialized['cephfs'] = true;
        $this->cephfs = $cephfs;

        return $this;
    }

    /**
     * Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.
     */
    public function getCinder(): ?IoK8sApiCoreV1CinderVolumeSource
    {
        return $this->cinder;
    }

    /**
     * Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.
     */
    public function setCinder(?IoK8sApiCoreV1CinderVolumeSource $cinder): self
    {
        $this->initialized['cinder'] = true;
        $this->cinder = $cinder;

        return $this;
    }

    /**
     * Adapts a ConfigMap into a volume.
     *
     * The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.
     */
    public function getConfigMap(): ?IoK8sApiCoreV1ConfigMapVolumeSource
    {
        return $this->configMap;
    }

    /**
     * Adapts a ConfigMap into a volume.
     *
     * The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.
     */
    public function setConfigMap(?IoK8sApiCoreV1ConfigMapVolumeSource $configMap): self
    {
        $this->initialized['configMap'] = true;
        $this->configMap = $configMap;

        return $this;
    }

    /**
     * Represents a source location of a volume to mount, managed by an external CSI driver.
     */
    public function getCsi(): ?IoK8sApiCoreV1CSIVolumeSource
    {
        return $this->csi;
    }

    /**
     * Represents a source location of a volume to mount, managed by an external CSI driver.
     */
    public function setCsi(?IoK8sApiCoreV1CSIVolumeSource $csi): self
    {
        $this->initialized['csi'] = true;
        $this->csi = $csi;

        return $this;
    }

    /**
     * DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
     */
    public function getDownwardAPI(): ?IoK8sApiCoreV1DownwardAPIVolumeSource
    {
        return $this->downwardAPI;
    }

    /**
     * DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
     */
    public function setDownwardAPI(?IoK8sApiCoreV1DownwardAPIVolumeSource $downwardAPI): self
    {
        $this->initialized['downwardAPI'] = true;
        $this->downwardAPI = $downwardAPI;

        return $this;
    }

    /**
     * Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.
     */
    public function getEmptyDir(): ?IoK8sApiCoreV1EmptyDirVolumeSource
    {
        return $this->emptyDir;
    }

    /**
     * Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.
     */
    public function setEmptyDir(?IoK8sApiCoreV1EmptyDirVolumeSource $emptyDir): self
    {
        $this->initialized['emptyDir'] = true;
        $this->emptyDir = $emptyDir;

        return $this;
    }

    /**
     * Represents an ephemeral volume that is handled by a normal storage driver.
     */
    public function getEphemeral(): ?IoK8sApiCoreV1EphemeralVolumeSource
    {
        return $this->ephemeral;
    }

    /**
     * Represents an ephemeral volume that is handled by a normal storage driver.
     */
    public function setEphemeral(?IoK8sApiCoreV1EphemeralVolumeSource $ephemeral): self
    {
        $this->initialized['ephemeral'] = true;
        $this->ephemeral = $ephemeral;

        return $this;
    }

    /**
     * Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling.
     */
    public function getFc(): ?IoK8sApiCoreV1FCVolumeSource
    {
        return $this->fc;
    }

    /**
     * Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling.
     */
    public function setFc(?IoK8sApiCoreV1FCVolumeSource $fc): self
    {
        $this->initialized['fc'] = true;
        $this->fc = $fc;

        return $this;
    }

    /**
     * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
     */
    public function getFlexVolume(): ?IoK8sApiCoreV1FlexVolumeSource
    {
        return $this->flexVolume;
    }

    /**
     * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
     */
    public function setFlexVolume(?IoK8sApiCoreV1FlexVolumeSource $flexVolume): self
    {
        $this->initialized['flexVolume'] = true;
        $this->flexVolume = $flexVolume;

        return $this;
    }

    /**
     * Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling.
     */
    public function getFlocker(): ?IoK8sApiCoreV1FlockerVolumeSource
    {
        return $this->flocker;
    }

    /**
     * Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling.
     */
    public function setFlocker(?IoK8sApiCoreV1FlockerVolumeSource $flocker): self
    {
        $this->initialized['flocker'] = true;
        $this->flocker = $flocker;

        return $this;
    }

    /**
     * Represents a Persistent Disk resource in Google Compute Engine.
     *
     * A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling.
     */
    public function getGcePersistentDisk(): ?IoK8sApiCoreV1GCEPersistentDiskVolumeSource
    {
        return $this->gcePersistentDisk;
    }

    /**
     * Represents a Persistent Disk resource in Google Compute Engine.
     *
     * A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling.
     */
    public function setGcePersistentDisk(?IoK8sApiCoreV1GCEPersistentDiskVolumeSource $gcePersistentDisk): self
    {
        $this->initialized['gcePersistentDisk'] = true;
        $this->gcePersistentDisk = $gcePersistentDisk;

        return $this;
    }

    /**
     * Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.
     *
     * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
     */
    public function getGitRepo(): ?IoK8sApiCoreV1GitRepoVolumeSource
    {
        return $this->gitRepo;
    }

    /**
     * Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.
     *
     * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
     */
    public function setGitRepo(?IoK8sApiCoreV1GitRepoVolumeSource $gitRepo): self
    {
        $this->initialized['gitRepo'] = true;
        $this->gitRepo = $gitRepo;

        return $this;
    }

    /**
     * Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling.
     */
    public function getGlusterfs(): ?IoK8sApiCoreV1GlusterfsVolumeSource
    {
        return $this->glusterfs;
    }

    /**
     * Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling.
     */
    public function setGlusterfs(?IoK8sApiCoreV1GlusterfsVolumeSource $glusterfs): self
    {
        $this->initialized['glusterfs'] = true;
        $this->glusterfs = $glusterfs;

        return $this;
    }

    /**
     * Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling.
     */
    public function getHostPath(): ?IoK8sApiCoreV1HostPathVolumeSource
    {
        return $this->hostPath;
    }

    /**
     * Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling.
     */
    public function setHostPath(?IoK8sApiCoreV1HostPathVolumeSource $hostPath): self
    {
        $this->initialized['hostPath'] = true;
        $this->hostPath = $hostPath;

        return $this;
    }

    /**
     * ImageVolumeSource represents a image volume resource.
     */
    public function getImage(): ?IoK8sApiCoreV1ImageVolumeSource
    {
        return $this->image;
    }

    /**
     * ImageVolumeSource represents a image volume resource.
     */
    public function setImage(?IoK8sApiCoreV1ImageVolumeSource $image): self
    {
        $this->initialized['image'] = true;
        $this->image = $image;

        return $this;
    }

    /**
     * Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.
     */
    public function getIscsi(): ?IoK8sApiCoreV1ISCSIVolumeSource
    {
        return $this->iscsi;
    }

    /**
     * Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.
     */
    public function setIscsi(?IoK8sApiCoreV1ISCSIVolumeSource $iscsi): self
    {
        $this->initialized['iscsi'] = true;
        $this->iscsi = $iscsi;

        return $this;
    }

    /**
     * name of the volume. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names.
     */
    public function getName(): ?string
    {
        return $this->name;
    }

    /**
     * name of the volume. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names.
     */
    public function setName(?string $name): self
    {
        $this->initialized['name'] = true;
        $this->name = $name;

        return $this;
    }

    /**
     * Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support ownership management or SELinux relabeling.
     */
    public function getNfs(): ?IoK8sApiCoreV1NFSVolumeSource
    {
        return $this->nfs;
    }

    /**
     * Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support ownership management or SELinux relabeling.
     */
    public function setNfs(?IoK8sApiCoreV1NFSVolumeSource $nfs): self
    {
        $this->initialized['nfs'] = true;
        $this->nfs = $nfs;

        return $this;
    }

    /**
     * PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).
     */
    public function getPersistentVolumeClaim(): ?IoK8sApiCoreV1PersistentVolumeClaimVolumeSource
    {
        return $this->persistentVolumeClaim;
    }

    /**
     * PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).
     */
    public function setPersistentVolumeClaim(?IoK8sApiCoreV1PersistentVolumeClaimVolumeSource $persistentVolumeClaim): self
    {
        $this->initialized['persistentVolumeClaim'] = true;
        $this->persistentVolumeClaim = $persistentVolumeClaim;

        return $this;
    }

    /**
     * Represents a Photon Controller persistent disk resource.
     */
    public function getPhotonPersistentDisk(): ?IoK8sApiCoreV1PhotonPersistentDiskVolumeSource
    {
        return $this->photonPersistentDisk;
    }

    /**
     * Represents a Photon Controller persistent disk resource.
     */
    public function setPhotonPersistentDisk(?IoK8sApiCoreV1PhotonPersistentDiskVolumeSource $photonPersistentDisk): self
    {
        $this->initialized['photonPersistentDisk'] = true;
        $this->photonPersistentDisk = $photonPersistentDisk;

        return $this;
    }

    /**
     * PortworxVolumeSource represents a Portworx volume resource.
     */
    public function getPortworxVolume(): ?IoK8sApiCoreV1PortworxVolumeSource
    {
        return $this->portworxVolume;
    }

    /**
     * PortworxVolumeSource represents a Portworx volume resource.
     */
    public function setPortworxVolume(?IoK8sApiCoreV1PortworxVolumeSource $portworxVolume): self
    {
        $this->initialized['portworxVolume'] = true;
        $this->portworxVolume = $portworxVolume;

        return $this;
    }

    /**
     * Represents a projected volume source.
     */
    public function getProjected(): ?IoK8sApiCoreV1ProjectedVolumeSource
    {
        return $this->projected;
    }

    /**
     * Represents a projected volume source.
     */
    public function setProjected(?IoK8sApiCoreV1ProjectedVolumeSource $projected): self
    {
        $this->initialized['projected'] = true;
        $this->projected = $projected;

        return $this;
    }

    /**
     * Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support ownership management or SELinux relabeling.
     */
    public function getQuobyte(): ?IoK8sApiCoreV1QuobyteVolumeSource
    {
        return $this->quobyte;
    }

    /**
     * Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support ownership management or SELinux relabeling.
     */
    public function setQuobyte(?IoK8sApiCoreV1QuobyteVolumeSource $quobyte): self
    {
        $this->initialized['quobyte'] = true;
        $this->quobyte = $quobyte;

        return $this;
    }

    /**
     * Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling.
     */
    public function getRbd(): ?IoK8sApiCoreV1RBDVolumeSource
    {
        return $this->rbd;
    }

    /**
     * Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling.
     */
    public function setRbd(?IoK8sApiCoreV1RBDVolumeSource $rbd): self
    {
        $this->initialized['rbd'] = true;
        $this->rbd = $rbd;

        return $this;
    }

    /**
     * ScaleIOVolumeSource represents a persistent ScaleIO volume.
     */
    public function getScaleIO(): ?IoK8sApiCoreV1ScaleIOVolumeSource
    {
        return $this->scaleIO;
    }

    /**
     * ScaleIOVolumeSource represents a persistent ScaleIO volume.
     */
    public function setScaleIO(?IoK8sApiCoreV1ScaleIOVolumeSource $scaleIO): self
    {
        $this->initialized['scaleIO'] = true;
        $this->scaleIO = $scaleIO;

        return $this;
    }

    /**
     * Adapts a Secret into a volume.
     *
     * The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.
     */
    public function getSecret(): ?IoK8sApiCoreV1SecretVolumeSource
    {
        return $this->secret;
    }

    /**
     * Adapts a Secret into a volume.
     *
     * The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.
     */
    public function setSecret(?IoK8sApiCoreV1SecretVolumeSource $secret): self
    {
        $this->initialized['secret'] = true;
        $this->secret = $secret;

        return $this;
    }

    /**
     * Represents a StorageOS persistent volume resource.
     */
    public function getStorageos(): ?IoK8sApiCoreV1StorageOSVolumeSource
    {
        return $this->storageos;
    }

    /**
     * Represents a StorageOS persistent volume resource.
     */
    public function setStorageos(?IoK8sApiCoreV1StorageOSVolumeSource $storageos): self
    {
        $this->initialized['storageos'] = true;
        $this->storageos = $storageos;

        return $this;
    }

    /**
     * Represents a vSphere volume resource.
     */
    public function getVsphereVolume(): ?IoK8sApiCoreV1VsphereVirtualDiskVolumeSource
    {
        return $this->vsphereVolume;
    }

    /**
     * Represents a vSphere volume resource.
     */
    public function setVsphereVolume(?IoK8sApiCoreV1VsphereVirtualDiskVolumeSource $vsphereVolume): self
    {
        $this->initialized['vsphereVolume'] = true;
        $this->vsphereVolume = $vsphereVolume;

        return $this;
    }
}
